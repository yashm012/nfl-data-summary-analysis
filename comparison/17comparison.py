# -*- coding: utf-8 -*-
"""comparison.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CDM3PA7cc1hDOaoUBlS26D42ekQL3r4u
"""

from IPython import get_ipython
from IPython.display import display
import pandas as pd
import matplotlib.pyplot as plt
import re
import seaborn as sns

# Assuming your datasets are in CSV format and named 'dataset21.csv', 'dataset22.csv', 'dataset23.csv'
dataset21 = pd.read_csv('2021.csv')
reg_season_21 = dataset21[dataset21['game_id'] <= 272]
playoff_21 = dataset21[dataset21['game_id'] >= 273]

dataset22 = pd.read_csv('2022.csv')
reg_season_22 = dataset22[dataset22['game_id'] <= 272]
playoff_22 = dataset22[dataset22['game_id'] >= 273]

dataset23 = pd.read_csv('2023.csv')
reg_season_23 = dataset23[dataset23['game_id'] <= 272]
playoff_23 = dataset23[dataset23['game_id'] >= 273]

dataset24 = pd.read_csv('2024.csv')
reg_season_24 = dataset21[dataset21['game_id'] <= 272]
playoff_24 = dataset21[dataset21['game_id'] >= 273]

# Assuming all datasets have the same structure with columns like 'home_team', 'away_team', 'home_score', 'away_score'
all_reg_season_data = pd.concat([reg_season_21, reg_season_22, reg_season_23, reg_season_24])
all_playoff_data = pd.concat([playoff_21, playoff_22, playoff_23, playoff_24])

def team_id(team_name):
    # Maps a team's name to its team ID
    team_mapping = {
        'Arizona': 'ARI',
        'Atlanta': 'ATL',
        'Baltimore': 'BAL',
        'Buffalo': 'BUF',
        'Carolina': 'CAR',
        'Chicago': 'CHI',
        'Cincinnati': 'CIN',
        'Cleveland': 'CLE',
        'Dallas': 'DAL',
        'Denver': 'DEN',
        'Detroit': 'DET',
        'Green Bay': 'GB',
        'Houston': 'HOU',
        'Indianapolis': 'IND',
        'Jacksonville': 'JAX',
        'Kansas City': 'KC',
        'Los Angeles': 'LAC',
        'Los Angeles': 'LAR',
        'Las Vegas': 'LV',
        'Miami': 'MIA',
        'Minnesota': 'MIN',
        'New England': 'NE',
        'New Orleans': 'NO',
        'New York': 'NYG',
        'New York': 'NYJ',
        'Philadelphia': 'PHI',
        'Pittsburgh': 'PIT',
        'San Francisco': 'SF',
        'Seattle': 'SEA',
        'Tampa Bay': 'TB',
        'Tennessee': 'TEN',
        r'Washington.*': 'WAS'  # Include regex to handle variations of Washington's name
    }
    for name, abbrev in team_mapping.items():
        if isinstance(name, str) and name == team_name:  # Check for direct match
            return abbrev
        elif re.match(name, team_name): # Check if the team name matches the regex pattern
            return abbrev

    return team_name #If no match is found, return the original team name

def get_playoff_teams(df):
    """Extracts unique playoff teams from a DataFrame based on game_id range."""
    playoff_games = df[(df['game_id'] >= 273) & (df['game_id'] <= 285)]  # Filter playoff games
    playoff_teams = set(playoff_games['home_team'].unique()).union(playoff_games['away_team'].unique())  # Get unique teams
    return list(playoff_teams)

# Get playoff teams for each year
playoff_teams_2021 = get_playoff_teams(dataset21)
playoff_teams_2022 = get_playoff_teams(dataset22)
playoff_teams_2023 = get_playoff_teams(dataset23)
playoff_teams_2024 = get_playoff_teams(dataset24)

def calculate_avg_scores(df):
    home_scores = df.groupby('home_team')['home_score'].mean().reset_index()
    away_scores = df.groupby('away_team')['away_score'].mean().reset_index()
    # Merge the home and away scores
    avg_scores = pd.merge(home_scores, away_scores, left_on='home_team', right_on='away_team')
    avg_scores = avg_scores.rename(columns={'home_team': 'team', 'home_score': 'avg_home_score', 'away_score': 'avg_away_score'})

    # Handle missing teams (Modified)
    all_teams = set(df['home_team'].unique()).union(df['away_team'].unique())
    missing_teams = all_teams - set(avg_scores['team'])

    for team in missing_teams:
        avg_scores = pd.concat([avg_scores, pd.DataFrame({'team': [team], 'avg_home_score': [0], 'avg_away_score': [0]})], ignore_index=True)

    # avg_scores = avg_scores.dropna()  # Remove this line to keep all teams

    return avg_scores

rs_avg_scores_21 = calculate_avg_scores(reg_season_21)
rs_avg_scores_22 = calculate_avg_scores(reg_season_22)
rs_avg_scores_23 = calculate_avg_scores(reg_season_23)
rs_avg_scores_24 = calculate_avg_scores(reg_season_24)

p_avg_scores_21 = calculate_avg_scores(playoff_21)
p_avg_scores_22 = calculate_avg_scores(playoff_22)
p_avg_scores_23 = calculate_avg_scores(playoff_23)
p_avg_scores_24 = calculate_avg_scores(playoff_24)

# Create subplots
fig, axes = plt.subplots(1, 4, figsize=(15, 5))

# Set the x and y limits for all subplots
for ax in axes:
    ax.set_xlim(7, 35)
    ax.set_ylim(7, 35)

# Scatterplot for 2021 with playoff teams highlighted
ax = axes[0]  # Assign the current axes object
for i, row in rs_avg_scores_21.iterrows():
    team_name = row['team']
    team_abbrev = team_id(team_name)
    is_playoff_team = team_name in playoff_teams_2021 or team_abbrev in playoff_teams_2021
    color = 'red' if is_playoff_team else 'blue'
    ax.scatter(row['avg_home_score'], row['avg_away_score'], color=color)
    ax.annotate(team_abbrev, (row['avg_home_score'], row['avg_away_score']))

ax.set_title('2021 RS: avg home score vs avg away score')
ax.set_xlabel('Average RS Home Score')
ax.set_ylabel('Average RS Away Score')

# Scatterplot for 2022 with playoff teams highlighted
ax = axes[1]  # Assign the current axes object
for i, row in rs_avg_scores_22.iterrows():
    team_name = row['team']
    team_abbrev = team_id(team_name)
    is_playoff_team = team_name in playoff_teams_2022 or team_abbrev in playoff_teams_2022
    color = 'red' if is_playoff_team else 'blue'
    ax.scatter(row['avg_home_score'], row['avg_away_score'], color=color)
    ax.annotate(team_abbrev, (row['avg_home_score'], row['avg_away_score']))

ax.set_title('2022 RS: avg home score vs avg away score')
ax.set_xlabel('Average RS Home Score')
ax.set_ylabel('Average RS Away Score')

# Scatterplot for 2023 with playoff teams highlighted
ax = axes[2]  # Assign the current axes object
for i, row in rs_avg_scores_23.iterrows():
    team_name = row['team']
    team_abbrev = team_id(team_name)
    is_playoff_team = team_name in playoff_teams_2023 or team_abbrev in playoff_teams_2023
    color = 'red' if is_playoff_team else 'blue'
    ax.scatter(row['avg_home_score'], row['avg_away_score'], color=color)
    ax.annotate(team_abbrev, (row['avg_home_score'], row['avg_away_score']))

ax.set_title('2023 RS: avg home score vs avg away score')
ax.set_xlabel('Average RS Home Score')
ax.set_ylabel('Average RS Away Score')

# Scatterplot for 2024 with playoff teams highlighted
ax = axes[3]  # Assign the current axes object
for i, row in rs_avg_scores_24.iterrows():
    team_name = row['team']
    team_abbrev = team_id(team_name)
    is_playoff_team = team_name in playoff_teams_2024 or team_abbrev in playoff_teams_2024
    color = 'red' if is_playoff_team else 'blue'
    ax.scatter(row['avg_home_score'], row['avg_away_score'], color=color)
    ax.annotate(team_abbrev, (row['avg_home_score'], row['avg_away_score']))

ax.set_title('2024 RS: avg home score vs avg away score')
ax.set_xlabel('Average RS Home Score')
ax.set_ylabel('Average RS Away Score')

# Create dummy scatter plots for the legend
ax.scatter([], [], color='red', label='Playoff Team')
ax.scatter([], [], color='blue', label='Non-Playoff Team')
ax.legend(loc='best')  # Adjust 'loc' for optimal placement

plt.tight_layout()
plt.show()

num_dots_2021 = len(rs_avg_scores_21)
num_dots_2022 = len(rs_avg_scores_22)
num_dots_2023 = len(rs_avg_scores_23)
num_dots_2024 = len(rs_avg_scores_24)

print(f"Number of dots in 2021: {num_dots_2021}")
print(f"Number of dots in 2022: {num_dots_2022}")
print(f"Number of dots in 2023: {num_dots_2023}")
print(f"Number of dots in 2024: {num_dots_2024}")

# Create subplots for spread countplots
fig, axes = plt.subplots(1, 4, figsize=(15, 5))

# Set the x and y limits for all subplots
for ax in axes:
    ax.set_xlim(-18.5, 0)
    ax.set_ylim(0, 75)

# Spread countplot for 2021
sns.histplot(dataset21['spread'], bins=20, ax=axes[0], color='skyblue')  # Using histplot from seaborn
axes[0].set_title('2021 Spread Distribution')
axes[0].set_xlabel('Spread')
axes[0].set_ylabel('Frequency')
axes[0].spines[['top', 'right']].set_visible(False)

# Spread countplot for 2022
sns.histplot(dataset22['spread'], bins=20, ax=axes[1], color='salmon')
axes[1].set_title('2022 Spread Distribution')
axes[1].set_xlabel('Spread')
axes[1].set_ylabel('Frequency')
axes[1].spines[['top', 'right']].set_visible(False)

# Spread countplot for 2023
sns.histplot(dataset23['spread'], bins=20, ax=axes[2], color='lightgreen')
axes[2].set_title('2023 Spread Distribution')
axes[2].set_xlabel('Spread')
axes[2].set_ylabel('Frequency')
axes[2].spines[['top', 'right']].set_visible(False)

# Spread countplot for 2024
sns.histplot(dataset24['spread'], bins=20, ax=axes[3], color='yellow')
axes[3].set_title('2024 Spread Distribution')
axes[3].set_xlabel('Spread')
axes[3].set_ylabel('Frequency')
axes[3].spines[['top', 'right']].set_visible(False)

plt.tight_layout()
plt.show()

years = [2021, 2022, 2023, 2024]
avg_total_points = []

for year in years:
  dataset = pd.read_csv(f'{year}.csv')
  avg_total_points.append(dataset[['home_score', 'away_score']].sum(axis=1).mean())

plt.plot(years, avg_total_points, marker='o')
plt.title('Average Total Points Scored per Game')
plt.xlabel('Year')
plt.ylabel('Average Points')
plt.grid(True)
plt.show()

def count_wins(df, playoff_games=False):
    """Counts the number of wins for each team, optionally filtering for playoff games."""
    if playoff_games:
        games_df = df[df['game_id'] >= 273]  # Filter for playoff games
    else:
        games_df = df[df['game_id'] <= 272]  # Filter for regular season games

    # Create a 'winner' column based on scores
    games_df['winner'] = games_df.apply(
        lambda row: row['home_team'] if row['home_score'] > row['away_score'] else row['away_team'],
        axis=1
    )

    wins_by_team = games_df.groupby('winner')['game_id'].count().reset_index()
    wins_by_team = wins_by_team.rename(columns={'winner': 'team', 'game_id': 'wins'})
    return wins_by_team

# Get regular season wins for each year
wins_2021 = count_wins(dataset21, playoff_games=False)
wins_2022 = count_wins(dataset22, playoff_games=False)
wins_2023 = count_wins(dataset23, playoff_games=False)
wins_2024 = count_wins(dataset24, playoff_games=False)

# Get playoff wins for each year
playoff_wins_2021 = count_wins(dataset21, playoff_games=True)
playoff_wins_2022 = count_wins(dataset22, playoff_games=True)
playoff_wins_2023 = count_wins(dataset23, playoff_games=True)
playoff_wins_2024 = count_wins(dataset24, playoff_games=True)

# Get all unique teams across all years
all_teams = set(wins_2021['team']).union(wins_2022['team']).union(wins_2023['team']).union(wins_2024['team'])

team_performance = {}
for year, wins_df, playoff_wins_df, playoff_teams in zip(
    [2021, 2022, 2023, 2024],
    [wins_2021, wins_2022, wins_2023, wins_2024],
    [playoff_wins_2021, playoff_wins_2022, playoff_wins_2023, playoff_wins_2024],
    [playoff_teams_2021, playoff_teams_2022, playoff_teams_2023, playoff_teams_2024],
):
    for team in all_teams:  # Iterate through all teams
        wins = wins_df.loc[wins_df['team'] == team, 'wins'].values[0] if team in wins_df['team'].values else 0
        playoff_wins = playoff_wins_df.loc[playoff_wins_df['team'] == team, 'wins'].values[0] if team in playoff_wins_df['team'].values else 0
        made_playoffs = team in playoff_teams

        # Adjust criteria to include playoff wins (example)
        if wins >= 10 and made_playoffs and playoff_wins >= 1:  # Example: Requires at least 2 playoff wins
            team_performance[team] = team_performance.get(team, 0) + 1
        else:
            team_performance[team] = team_performance.get(team, 0)  # Initialize to 0 if not meeting criteria

team_classifications = {}
for team, playoff_count in team_performance.items():
    # Calculate average wins over 4 years (including playoff wins)
    yearly_wins = [wins_df.loc[wins_df['team'] == team, 'wins'].values[0] if team in wins_df['team'].values else 0
                   for wins_df in [wins_2021, wins_2022, wins_2023, wins_2024]]
    yearly_playoff_wins = [playoff_wins_df.loc[playoff_wins_df['team'] == team, 'wins'].values[0] if team in playoff_wins_df['team'].values else 0
                           for playoff_wins_df in [playoff_wins_2021, playoff_wins_2022, playoff_wins_2023, playoff_wins_2024]]

    avg_wins = sum(yearly_wins) / len(yearly_wins)
    avg_playoff_wins = sum(yearly_playoff_wins) / len(yearly_playoff_wins)

    # Introduce tolerance for average wins
    if playoff_count == 4 and avg_wins >= 10 and avg_playoff_wins >= 2:
        team_classifications[team] = "Dynasty"
    elif playoff_count >= 3 and avg_wins >= 10 and avg_playoff_wins >=1:
        team_classifications[team] = "Dominant"
    elif playoff_count >= 2 and avg_wins >= 10:
        team_classifications[team] = "Annual Contender"
    elif playoff_count >= 2 or avg_wins >= 10:
        team_classifications[team] = "Inconsistent Contender"
    elif (8 <= avg_wins < 10):  # Tolerance for Mediocre category
        team_classifications[team] = "Mediocre"
    elif (1 <= avg_wins <= 6):
        team_classifications[team] = "BOTB" # 'bottom of the barrel' teams
    else:
        team_classifications[team] = "Non-Contender"

team_classification_df = pd.DataFrame(
    list(team_classifications.items()), columns=["Team", "Classification"]
)
print(team_classification_df)

!pip install plotly==5.15.0
import plotly.express as px

# Create a list of years
years = [2021, 2022, 2023, 2024]

# Create an empty list to store the data for the chart
chart_data = []

# Iterate through the years and teams to accumulate the data
for year, wins_df in zip(years, [wins_2021, wins_2022, wins_2023, wins_2024]):
    for team in wins_df['team']:
        wins = wins_df.loc[wins_df['team'] == team, 'wins'].values[0]
        chart_data.append([team, year, wins])

# Create a Pandas DataFrame from the chart data
df_chart = pd.DataFrame(chart_data, columns=['Team', 'Year', 'Wins'])

# Calculate total wins for each team across all seasons
df_chart['Total Wins'] = df_chart.groupby('Team')['Wins'].transform('sum')

# Create a list of unique teams
teams = df_chart['Team'].unique()

# Convert 'Year' column to integer type and filter out non-integer values
df_chart['Year'] = pd.to_numeric(df_chart['Year'], errors='coerce').astype('Int64')  # Convert to numeric, handling errors
df_chart = df_chart[df_chart['Year'].notna()]  # Filter out NaN values (introduced by errors)

# Create a 'Playoffs' column indicating whether the team made the playoffs in that year
df_chart['Playoffs'] = df_chart.apply(lambda row: row['Team'] in globals()[f'playoff_teams_{row["Year"]}'], axis=1)

# Create an interactive bar chart with a dropdown for team selection
fig = px.bar(df_chart, x='Year', y='Wins', 
             color='Year', 
             animation_frame='Team',  
             title='Regular Season Wins by Team (2021-2024)',
             labels={'Wins': 'Regular Season Wins', 'Year': 'Season'},
             hover_data=['Total Wins', 'Playoffs'],  # Include Playoffs in hover data
             category_orders={'Team': teams})
             

# Update layout for better visualization
fig.update_layout(barmode='stack',
                  xaxis={'categoryorder': 'total descending'},
                  legend_title_text='Season',
                  yaxis_range=[0, df_chart['Wins'].max() + 2])  # Set y-axis range

# Customize the animation buttons
fig.update_layout(updatemenus=[
    dict(
        type="buttons",
        buttons=[dict(label="Play", method="animate", args=[None]),
                 dict(label="Pause", method="animate", args=[None, {"frame": {"duration": 1, "redraw": False},
                                                                  "mode": "immediate",
                                                                  "transition": {"duration": 0}}])],
    )
])

# Show the chart
fig.show()
